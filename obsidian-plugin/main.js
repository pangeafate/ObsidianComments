/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  ShareNotePlugin: () => ShareNotePlugin,
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  backendUrl: "https://obsidiancomments.serverado.app",
  copyToClipboard: true,
  showNotifications: true,
  openInBrowser: false
};

// src/api-client.ts
var ApiClient = class {
  constructor(config) {
    if (config.apiKey && config.apiKey.trim() === "") {
      config = { ...config, apiKey: "" };
    }
    try {
      new URL(config.serverUrl);
    } catch (e) {
      throw new Error("Invalid server URL");
    }
    this.config = config;
    this.timeout = config.timeout || 5e3;
  }
  get settings() {
    return this.config;
  }
  async shareNote(content, title, shareId) {
    const url = `${this.config.serverUrl}/api/notes/share`;
    const extractedTitle = title || "Untitled Document";
    try {
      const requestBody = {
        content,
        title: extractedTitle
      };
      if (shareId) {
        requestBody.shareId = shareId;
      }
      const response = await this.makeRequest(url, {
        method: "POST",
        headers: this.getHeaders(),
        body: JSON.stringify(requestBody)
      });
      if (!response.ok) {
        await this.handleErrorResponse(response);
      }
      const data = await response.json();
      return {
        shareUrl: data.shareUrl,
        // Backend now consistently returns shareUrl
        shareId: data.shareId,
        createdAt: data.createdAt || (/* @__PURE__ */ new Date()).toISOString(),
        permissions: data.permissions || "edit"
      };
    } catch (error) {
      if (error instanceof Error && error.message === "Request timeout") {
        throw error;
      }
      if (error instanceof Error && error.message.includes("Network")) {
        throw new Error("Failed to connect to sharing service. Please check your internet connection.");
      }
      throw error;
    }
  }
  async updateNote(shareId, content) {
    const url = `${this.config.serverUrl}/api/notes/${shareId}`;
    const response = await this.makeRequest(url, {
      method: "PUT",
      headers: this.getHeaders(),
      body: JSON.stringify({ content })
    });
    if (!response.ok) {
      await this.handleErrorResponse(response);
    }
    const data = await response.json();
    return {
      shareId: data.shareId,
      updatedAt: data.updatedAt,
      version: data.version
    };
  }
  async getSharedNote(shareId) {
    const url = `${this.config.serverUrl}/api/notes/${shareId}`;
    const response = await this.makeRequest(url, {
      method: "GET",
      headers: this.getHeaders()
    });
    if (!response.ok) {
      await this.handleErrorResponse(response);
    }
    return await response.json();
  }
  async deleteShare(shareId) {
    const url = `${this.config.serverUrl}/api/notes/${shareId}`;
    const response = await this.makeRequest(url, {
      method: "DELETE",
      headers: this.getHeaders()
    });
    if (!response.ok) {
      await this.handleErrorResponse(response);
    }
  }
  async listShares() {
    const url = `${this.config.serverUrl}/api/notes`;
    const response = await this.makeRequest(url, {
      method: "GET",
      headers: this.getHeaders()
    });
    if (!response.ok) {
      await this.handleErrorResponse(response);
    }
    const data = await response.json();
    return {
      shares: data.shares || [],
      total: data.total || 0
    };
  }
  async testConnection() {
    const url = `${this.config.serverUrl}/api/auth/test`;
    const response = await this.makeRequest(url, {
      method: "GET",
      headers: this.getHeaders()
    });
    if (!response.ok) {
      await this.handleErrorResponse(response);
    }
    const data = await response.json();
    return {
      valid: data.valid,
      user: data.user,
      limits: data.limits
    };
  }
  async makeRequest(url, options) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal,
        credentials: "omit",
        // Don't send credentials to avoid CORS complications
        mode: "cors"
        // Explicitly set CORS mode
      });
      clearTimeout(timeoutId);
      return response;
    } catch (error) {
      clearTimeout(timeoutId);
      if (error instanceof Error && error.name === "AbortError") {
        throw new Error("Request timeout");
      }
      throw new Error("Network error");
    }
  }
  getHeaders() {
    const headers = {
      "Content-Type": "application/json",
      "User-Agent": "ObsidianComments/1.0.0"
    };
    if (this.config.apiKey) {
      headers["Authorization"] = `Bearer ${this.config.apiKey}`;
    }
    return headers;
  }
  async handleErrorResponse(response) {
    let errorData;
    try {
      errorData = await response.json();
    } catch (e) {
      errorData = { message: "Unknown error" };
    }
    switch (response.status) {
      case 401:
        throw new Error("API key is invalid or expired");
      case 404:
        throw new Error("Shared note not found. It may have been deleted.");
      case 429:
        throw new Error("Too many requests. Please wait before trying again.");
      case 500:
        throw new Error("Server error. Please try again later.");
      default:
        throw new Error(errorData.message || `HTTP ${response.status} error`);
    }
  }
};

// src/share-manager.ts
var ShareManager = class {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }
  async addShareMetadata(content, shareUrl, sharedAt) {
    const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n/;
    const match = content.match(frontmatterRegex);
    if (match) {
      const existingFrontmatter = match[1];
      const contentWithoutFrontmatter = content.substring(match[0].length);
      const cleanedFrontmatter = existingFrontmatter.split("\n").filter(
        (line) => !line.trim().startsWith("shareUrl:") && !line.trim().startsWith("shareId:") && !line.trim().startsWith("sharedAt:")
      ).join("\n");
      const newFrontmatter = `${cleanedFrontmatter}
shareUrl: ${shareUrl}
sharedAt: ${sharedAt}`;
      return `---
${newFrontmatter}
---
${contentWithoutFrontmatter}`;
    } else {
      const newFrontmatter = `shareUrl: ${shareUrl}
sharedAt: ${sharedAt}`;
      return `---
${newFrontmatter}
---
${content}`;
    }
  }
  async updateShareMetadata(content, shareUrl, sharedAt) {
    const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n/;
    const match = content.match(frontmatterRegex);
    if (match) {
      const existingFrontmatter = match[1];
      const contentWithoutFrontmatter = content.substring(match[0].length);
      const cleanedLines = existingFrontmatter.split("\n").filter(
        (line) => !line.trim().startsWith("shareUrl:") && !line.trim().startsWith("shareId:") && !line.trim().startsWith("sharedAt:")
      );
      cleanedLines.push(`shareUrl: ${shareUrl}`);
      cleanedLines.push(`sharedAt: ${sharedAt}`);
      return `---
${cleanedLines.join("\n")}
---
${contentWithoutFrontmatter}`;
    } else {
      return await this.addShareMetadata(content, shareUrl, sharedAt);
    }
  }
  async removeShareMetadata(content) {
    const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n/;
    const match = content.match(frontmatterRegex);
    if (!match) {
      return content;
    }
    const frontmatter = match[1];
    const contentWithoutFrontmatter = content.substring(match[0].length);
    const lines = frontmatter.split("\n").filter(
      (line) => !line.trim().startsWith("shareUrl:") && !line.trim().startsWith("shareId:") && !line.trim().startsWith("sharedAt:")
    );
    if (lines.length === 0 || lines.every((line) => line.trim() === "")) {
      return contentWithoutFrontmatter;
    } else {
      return `---
${lines.join("\n")}
---
${contentWithoutFrontmatter}`;
    }
  }
  isNoteShared(content) {
    try {
      const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n/;
      const match = content.match(frontmatterRegex);
      if (!match) {
        return false;
      }
      const frontmatter = match[1];
      if (frontmatter.includes("[unclosed") || frontmatter.includes("invalid yaml:")) {
        return false;
      }
      return (frontmatter.includes("shareUrl:") || frontmatter.includes("shareId:")) && frontmatter.split("\n").some((line) => {
        const shareUrlMatch = line.trim().match(/^shareUrl:\s*(.+)$/);
        const shareIdMatch = line.trim().match(/^shareId:\s*(.+)$/);
        return shareUrlMatch && shareUrlMatch[1].trim() !== "" || shareIdMatch && shareIdMatch[1].trim() !== "";
      });
    } catch (error) {
      return false;
    }
  }
  getShareUrl(content) {
    try {
      const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n/;
      const match = content.match(frontmatterRegex);
      if (!match) {
        return null;
      }
      const frontmatter = match[1];
      if (frontmatter.includes("[unclosed") || frontmatter.includes("invalid yaml:")) {
        return null;
      }
      const lines = frontmatter.split("\n");
      for (const line of lines) {
        const shareUrlMatch = line.trim().match(/^shareUrl:\s*(.+)$/);
        if (shareUrlMatch) {
          const shareUrl = shareUrlMatch[1].trim();
          return shareUrl === "" ? null : shareUrl;
        }
      }
      return null;
    } catch (error) {
      return null;
    }
  }
  getShareId(content) {
    try {
      const shareUrl = this.getShareUrl(content);
      if (shareUrl) {
        const editorMatch = shareUrl.match(/\/editor\/([^\/]+)$/);
        const shareMatch = shareUrl.match(/\/share\/([^\/]+)$/);
        return editorMatch ? editorMatch[1] : shareMatch ? shareMatch[1] : null;
      }
      const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n/;
      const fmMatch = content.match(frontmatterRegex);
      if (!fmMatch) {
        return null;
      }
      const frontmatter = fmMatch[1];
      const lines = frontmatter.split("\n");
      for (const line of lines) {
        const shareIdMatch = line.trim().match(/^shareId:\s*(.+)$/);
        if (shareIdMatch) {
          const shareId = shareIdMatch[1].trim();
          return shareId === "" ? null : shareId;
        }
      }
      return null;
    } catch (error) {
      return null;
    }
  }
  async shareNote(content) {
    const existingShareId = this.getShareId(content);
    if (existingShareId) {
      const updateResult = await this.apiClient.updateNote(existingShareId, content);
      const existingShareUrl = this.getShareUrl(content);
      const shareUrl = existingShareUrl || `${this.apiClient.settings.serverUrl}/editor/${existingShareId}`;
      const updatedContent = await this.updateShareMetadata(content, shareUrl, (/* @__PURE__ */ new Date()).toISOString());
      return {
        shareUrl,
        shareId: existingShareId,
        updatedContent,
        wasUpdate: true
      };
    } else {
      const uniqueShareId = `obsidian-${Date.now()}-${Math.random().toString(36).substring(7)}`;
      const extractedTitle = "Untitled Document";
      const shareResponse = await this.apiClient.shareNote(content, extractedTitle, uniqueShareId);
      const updatedContent = await this.addShareMetadata(
        content,
        shareResponse.shareUrl,
        // This is now collaborativeUrl from backend
        shareResponse.createdAt || (/* @__PURE__ */ new Date()).toISOString()
      );
      return {
        shareUrl: shareResponse.shareUrl,
        shareId: shareResponse.shareId,
        updatedContent,
        wasUpdate: false
      };
    }
  }
  async reshareNote(content) {
    return await this.shareNote(content);
  }
  async shareNoteWithFilename(content, filename) {
    const preparedContent = this.prepareContentWithTitle(content, filename);
    const cleanFilename = this.cleanFilename(filename);
    const existingShareId = this.getShareId(preparedContent);
    if (existingShareId) {
      const updateResult = await this.apiClient.updateNote(existingShareId, preparedContent);
      const existingShareUrl = this.getShareUrl(preparedContent);
      const shareUrl = existingShareUrl || `${this.apiClient.settings.serverUrl}/editor/${existingShareId}`;
      const updatedContent = await this.updateShareMetadata(preparedContent, shareUrl, (/* @__PURE__ */ new Date()).toISOString());
      return {
        shareUrl,
        shareId: existingShareId,
        updatedContent,
        wasUpdate: true
      };
    } else {
      const uniqueShareId = `obsidian-${Date.now()}-${Math.random().toString(36).substring(7)}`;
      const shareResponse = await this.apiClient.shareNote(preparedContent, cleanFilename, uniqueShareId);
      const updatedContent = await this.addShareMetadata(
        preparedContent,
        shareResponse.shareUrl,
        // This is now collaborativeUrl from backend
        shareResponse.createdAt || (/* @__PURE__ */ new Date()).toISOString()
      );
      return {
        shareUrl: shareResponse.shareUrl,
        shareId: shareResponse.shareId,
        updatedContent,
        wasUpdate: false
      };
    }
  }
  prepareContentWithTitle(content, filename) {
    return content;
  }
  cleanFilename(filename) {
    const withoutExtension = filename.replace(/\.[^/.]+$/, "");
    return withoutExtension;
  }
  async unshareNote(content) {
    const shareId = this.getShareId(content);
    if (!shareId) {
      return content;
    }
    await this.deleteFromDatabaseSafely(shareId);
    return await this.removeShareMetadata(content);
  }
  async deleteFromDatabaseSafely(shareId, maxRetries = 2) {
    let lastError = null;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`\u{1F5D1}\uFE0F Attempting to delete note ${shareId} from database (attempt ${attempt})`);
        await this.apiClient.deleteShare(shareId);
        console.log(`\u2705 Successfully deleted note ${shareId} from database`);
        return;
      } catch (error) {
        lastError = error instanceof Error ? error : new Error("Unknown error");
        console.warn(`\u26A0\uFE0F Delete attempt ${attempt} failed for ${shareId}:`, lastError.message);
        if (error instanceof Error) {
          if (error.message.includes("not found") || error.message.includes("404")) {
            console.log(`\u2139\uFE0F Note ${shareId} already deleted or not found in database`);
            return;
          }
          if (error.message.includes("invalid") || error.message.includes("401")) {
            console.error(`\u274C Authentication error for ${shareId}, not retrying`);
            return;
          }
        }
        if (attempt < maxRetries) {
          const delay = attempt * 1e3;
          console.log(`\u23F3 Waiting ${delay}ms before retry...`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
    }
    console.error(`\u274C Failed to delete note ${shareId} from database after ${maxRetries} attempts:`, lastError == null ? void 0 : lastError.message);
    console.log(`\u{1F9F9} Continuing with local frontmatter removal for ${shareId}`);
  }
};

// src/main.ts
var ShareNotePlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.statusBarItem = null;
  }
  async onload() {
    await this.loadSettings();
    this.apiClient = new ApiClient({
      serverUrl: this.settings.backendUrl,
      apiKey: "",
      // Anonymous usage for now
      timeout: 1e4
    });
    this.shareManager = new ShareManager(this.apiClient);
    this.addRibbonIcon("share", "Share note", () => {
      this.shareCurrentNote();
    });
    this.addCommand({
      id: "share-note",
      name: "Share current note",
      callback: () => this.shareCurrentNote()
    });
    this.addCommand({
      id: "unshare-note",
      name: "Stop sharing current note",
      callback: () => this.unshareCurrentNote()
    });
    this.statusBarItem = this.addStatusBarItem();
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.updateStatusBar();
      })
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        if (file === this.app.workspace.getActiveFile()) {
          this.updateStatusBar();
        }
      })
    );
    this.updateStatusBar();
    this.addSettingTab(new ShareNoteSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.apiClient = new ApiClient({
      serverUrl: this.settings.backendUrl,
      apiKey: "",
      // Anonymous usage for now
      timeout: 1e4
    });
    this.shareManager = new ShareManager(this.apiClient);
  }
  async shareCurrentNote() {
    try {
      const file = this.app.workspace.getActiveFile();
      if (!file) {
        new import_obsidian.Notice("No active file");
        return;
      }
      if (!this.isTextFile(file)) {
        new import_obsidian.Notice("Only text files can be shared");
        return;
      }
      const content = await this.app.vault.read(file);
      const cleanedContent = this.cleanMarkdownContent(content);
      const result = await this.shareManager.shareNoteWithFilename(cleanedContent, file.basename);
      await this.app.vault.modify(file, result.updatedContent);
      if (this.settings.copyToClipboard && navigator.clipboard) {
        await navigator.clipboard.writeText(result.shareUrl);
      }
      if (this.settings.openInBrowser) {
        window.open(result.shareUrl, "_blank");
      }
      if (this.settings.showNotifications) {
        const action = result.wasUpdate ? "updated" : "shared";
        new import_obsidian.Notice(`Note ${action} successfully!`);
      }
      this.updateStatusBar();
    } catch (error) {
      console.error("Failed to share note:", error);
      if (this.settings.showNotifications) {
        new import_obsidian.Notice(`Failed to share note: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
      throw error;
    }
  }
  async renderToHTML() {
    var _a, _b;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view)
      return "";
    const currentState = view.getState();
    await view.setState({
      ...currentState,
      mode: "preview"
    }, { history: false });
    await new Promise((resolve) => setTimeout(resolve, 100));
    const previewElement = (_b = (_a = view.previewMode) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.querySelector(".markdown-preview-view");
    if (!previewElement)
      return "";
    return this.cleanHTML(previewElement);
  }
  cleanHTML(element) {
    const cloned = element.cloneNode(true);
    cloned.querySelectorAll(".frontmatter").forEach((el) => el.remove());
    cloned.querySelectorAll(".edit-block-button").forEach((el) => el.remove());
    cloned.querySelectorAll("img").forEach((img) => {
      img.removeAttribute("data-obsidian-id");
      img.removeAttribute("data-embed-name");
    });
    cloned.querySelectorAll("script").forEach((el) => el.remove());
    cloned.querySelectorAll("iframe").forEach((el) => el.remove());
    cloned.querySelectorAll("embed").forEach((el) => el.remove());
    cloned.querySelectorAll("object").forEach((el) => el.remove());
    const binaryExtensions = [".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx", ".zip", ".rar"];
    binaryExtensions.forEach((ext) => {
      cloned.querySelectorAll(`a[href*="${ext}"]`).forEach((el) => el.remove());
    });
    cloned.querySelectorAll("a.internal-link").forEach((link) => {
      const textNode = document.createTextNode(link.textContent || "");
      link.replaceWith(textNode);
    });
    return cloned.innerHTML;
  }
  isTextFile(file) {
    const textExtensions = [".md", ".txt", ".org", ".tex", ".rst"];
    const binaryExtensions = [
      ".pdf",
      ".doc",
      ".docx",
      ".xls",
      ".xlsx",
      ".ppt",
      ".pptx",
      ".jpg",
      ".jpeg",
      ".png",
      ".gif",
      ".bmp",
      ".svg",
      ".webp",
      ".mp4",
      ".avi",
      ".mov",
      ".wmv",
      ".flv",
      ".mkv",
      ".webm",
      ".mp3",
      ".wav",
      ".flac",
      ".aac",
      ".ogg",
      ".m4a",
      ".zip",
      ".rar",
      ".7z",
      ".tar",
      ".gz",
      ".exe",
      ".dll",
      ".so"
    ];
    const extension = "." + (file.extension || "");
    if (textExtensions.includes(extension.toLowerCase())) {
      return true;
    }
    if (binaryExtensions.includes(extension.toLowerCase())) {
      return false;
    }
    return true;
  }
  cleanMarkdownContent(content) {
    if (!content || typeof content !== "string")
      return "";
    let cleanedContent = content;
    const frontmatterMatch = cleanedContent.match(/^---[\s\S]*?---\s*/);
    if (frontmatterMatch) {
      const frontmatter = frontmatterMatch[0];
      const contentAfterFrontmatter = cleanedContent.substring(frontmatter.length);
      const contentWithoutTitle = contentAfterFrontmatter.replace(/^\s*#\s+[^\r\n]*(\r\n?|\n|$)/, "");
      cleanedContent = frontmatter + contentWithoutTitle.trimStart();
    } else {
      const contentWithoutTitle = cleanedContent.replace(/^\s*#\s+[^\r\n]*(\r\n?|\n|$)/, "");
      cleanedContent = contentWithoutTitle.trimStart();
    }
    const binaryExtensions = [
      "pdf",
      "doc",
      "docx",
      "xls",
      "xlsx",
      "ppt",
      "pptx",
      "zip",
      "rar",
      "7z",
      "tar",
      "gz",
      "exe"
    ];
    const binaryAttachmentPattern = new RegExp(`\\[\\[([^\\]]+\\.(${binaryExtensions.join("|")}))(\\|[^\\]]*)?\\]\\]`, "gi");
    cleanedContent = cleanedContent.replace(binaryAttachmentPattern, "");
    cleanedContent = cleanedContent.replace(/!\[\[([^\]]+)\]\]/g, "");
    cleanedContent = cleanedContent.replace(/<(script|style|object|embed|iframe)[^>]*>[\s\S]*?<\/\1>/gi, "");
    cleanedContent = cleanedContent.replace(/<(script|style|object|embed|iframe)[^>]*\/>/gi, "");
    cleanedContent = cleanedContent.replace(/\n\s*\n\s*\n/g, "\n\n");
    return cleanedContent.trim();
  }
  extractCleanTitle(file, content) {
    let title = file.basename;
    title = title.replace(/[-_]/g, " ");
    title = title.replace(/\s+/g, " ");
    title = title.trim();
    if (!title || title.length === 0) {
      const h1Match = content.match(/^#\s+(.+)$/m);
      if (h1Match && h1Match[1].trim()) {
        title = h1Match[1].trim();
        title = title.replace(/[*_`~]/g, "");
        title = title.replace(/<[^>]*>/g, "");
      }
    }
    if (!title || title.length === 0) {
      title = "Untitled Note";
    }
    return title;
  }
  async unshareCurrentNote() {
    try {
      const file = this.app.workspace.getActiveFile();
      if (!file) {
        new import_obsidian.Notice("No active file");
        return;
      }
      const content = await this.app.vault.read(file);
      if (!this.shareManager.isNoteShared(content)) {
        new import_obsidian.Notice("Note is not currently shared");
        return;
      }
      const confirmModal = new ConfirmModal(
        this.app,
        "Stop sharing this note?",
        "This will remove the shared link. Anyone with the link will no longer be able to access it."
      );
      confirmModal.onConfirm = async () => {
        try {
          const updatedContent = await this.shareManager.unshareNote(content);
          await this.app.vault.modify(file, updatedContent);
          if (this.settings.showNotifications) {
            new import_obsidian.Notice("Note unshared successfully");
          }
          this.updateStatusBar();
        } catch (error) {
          console.error("Failed to unshare note:", error);
          if (this.settings.showNotifications) {
            new import_obsidian.Notice(`Failed to unshare note: ${error instanceof Error ? error.message : "Unknown error"}`);
          }
          this.updateStatusBar();
        }
      };
      confirmModal.open();
    } catch (error) {
      console.error("Failed to unshare note:", error);
      if (this.settings.showNotifications) {
        new import_obsidian.Notice(`Failed to unshare note: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  async updateStatusBar() {
    if (!this.statusBarItem)
      return;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      this.statusBarItem.setText("");
      return;
    }
    try {
      const content = await this.app.vault.read(activeFile);
      if (this.shareManager.isNoteShared(content)) {
        const shareUrl = this.shareManager.getShareUrl(content);
        this.statusBarItem.setText("\u{1F517} Shared");
        this.statusBarItem.addClass("mod-clickable");
        this.statusBarItem.setAttribute("aria-label", "Left-click: copy link | Right-click: unshare");
        this.statusBarItem.onclick = async (e) => {
          e.preventDefault();
          if (shareUrl && navigator.clipboard) {
            await navigator.clipboard.writeText(shareUrl);
            new import_obsidian.Notice("Share link copied to clipboard");
          }
        };
        this.statusBarItem.oncontextmenu = async (e) => {
          e.preventDefault();
          const menu = new import_obsidian.Menu();
          menu.addItem((item) => {
            item.setTitle("Copy share link").setIcon("copy").onClick(async () => {
              if (shareUrl && navigator.clipboard) {
                await navigator.clipboard.writeText(shareUrl);
                new import_obsidian.Notice("Share link copied to clipboard");
              }
            });
          });
          menu.addItem((item) => {
            item.setTitle("Re-share (update)").setIcon("upload").onClick(async () => {
              await this.shareCurrentNote();
            });
          });
          menu.addSeparator();
          menu.addItem((item) => {
            item.setTitle("Stop sharing").setIcon("trash").onClick(async () => {
              await this.unshareCurrentNote();
            });
          });
          menu.showAtMouseEvent(e);
        };
      } else {
        this.statusBarItem.setText("");
        this.statusBarItem.removeClass("mod-clickable");
        this.statusBarItem.onclick = null;
        this.statusBarItem.oncontextmenu = null;
      }
    } catch (error) {
      console.error("Error updating status bar:", error);
      this.statusBarItem.setText("");
    }
  }
};
var ShareNoteSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Share Note Settings" });
    new import_obsidian.Setting(containerEl).setName("Backend URL").setDesc("URL of your backend server").addText((text) => text.setPlaceholder("https://your-backend.com").setValue(this.plugin.settings.backendUrl).onChange(async (value) => {
      this.plugin.settings.backendUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Copy to clipboard").setDesc("Automatically copy share URL to clipboard").addToggle((toggle) => toggle.setValue(this.plugin.settings.copyToClipboard).onChange(async (value) => {
      this.plugin.settings.copyToClipboard = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show notifications").setDesc("Show success/error notifications").addToggle((toggle) => toggle.setValue(this.plugin.settings.showNotifications).onChange(async (value) => {
      this.plugin.settings.showNotifications = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Open in browser").setDesc("Automatically open shared note in browser").addToggle((toggle) => toggle.setValue(this.plugin.settings.openInBrowser).onChange(async (value) => {
      this.plugin.settings.openInBrowser = value;
      await this.plugin.saveSettings();
    }));
  }
};
var ConfirmModal = class extends import_obsidian.Modal {
  constructor(app, title, message) {
    super(app);
    this.onConfirm = () => {
    };
    this.title = title;
    this.message = message;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.title });
    contentEl.createEl("p", { text: this.message });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => this.close());
    const confirmButton = buttonContainer.createEl("button", { text: "Delete", cls: "mod-warning" });
    confirmButton.addEventListener("click", () => {
      this.onConfirm();
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var main_default = ShareNotePlugin;
