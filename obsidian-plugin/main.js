/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  ObsidianCommentsPlugin: () => ObsidianCommentsPlugin,
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/api-client.ts
var ApiClient = class {
  constructor(config) {
    if (config.apiKey && config.apiKey.trim() === "") {
      config = { ...config, apiKey: "" };
    }
    try {
      new URL(config.serverUrl);
    } catch (e) {
      throw new Error("Invalid server URL");
    }
    this.config = config;
    this.timeout = config.timeout || 5e3;
  }
  get settings() {
    return this.config;
  }
  async shareNote(content) {
    const url = `${this.config.serverUrl}/api/notes/share`;
    try {
      const response = await this.makeRequest(url, {
        method: "POST",
        headers: this.getHeaders(),
        body: JSON.stringify({ content })
      });
      if (!response.ok) {
        await this.handleErrorResponse(response);
      }
      const data = await response.json();
      return {
        shareUrl: data.shareUrl,
        shareId: data.shareId,
        createdAt: data.createdAt,
        permissions: data.permissions
      };
    } catch (error) {
      if (error instanceof Error && error.message === "Request timeout") {
        throw error;
      }
      if (error instanceof Error && error.message.includes("Network")) {
        throw new Error("Failed to connect to sharing service. Please check your internet connection.");
      }
      throw error;
    }
  }
  async updateNote(shareId, content) {
    const url = `${this.config.serverUrl}/api/notes/${shareId}`;
    const response = await this.makeRequest(url, {
      method: "PUT",
      headers: this.getHeaders(),
      body: JSON.stringify({ content })
    });
    if (!response.ok) {
      await this.handleErrorResponse(response);
    }
    const data = await response.json();
    return {
      shareId: data.shareId,
      updatedAt: data.updatedAt,
      version: data.version
    };
  }
  async deleteShare(shareId) {
    const url = `${this.config.serverUrl}/api/notes/${shareId}`;
    const response = await this.makeRequest(url, {
      method: "DELETE",
      headers: this.getHeaders()
    });
    if (!response.ok) {
      await this.handleErrorResponse(response);
    }
  }
  async listShares() {
    const url = `${this.config.serverUrl}/api/notes`;
    const response = await this.makeRequest(url, {
      method: "GET",
      headers: this.getHeaders()
    });
    if (!response.ok) {
      await this.handleErrorResponse(response);
    }
    const data = await response.json();
    return {
      shares: data.shares || [],
      total: data.total || 0
    };
  }
  async testConnection() {
    const url = `${this.config.serverUrl}/api/auth/test`;
    const response = await this.makeRequest(url, {
      method: "GET",
      headers: this.getHeaders()
    });
    if (!response.ok) {
      await this.handleErrorResponse(response);
    }
    const data = await response.json();
    return {
      valid: data.valid,
      user: data.user,
      limits: data.limits
    };
  }
  async makeRequest(url, options) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      return response;
    } catch (error) {
      clearTimeout(timeoutId);
      if (error instanceof Error && error.name === "AbortError") {
        throw new Error("Request timeout");
      }
      throw new Error("Network error");
    }
  }
  getHeaders() {
    const headers = {
      "Content-Type": "application/json",
      "User-Agent": "ObsidianComments/1.0.0"
    };
    if (this.config.apiKey) {
      headers["Authorization"] = `Bearer ${this.config.apiKey}`;
    }
    return headers;
  }
  async handleErrorResponse(response) {
    let errorData;
    try {
      errorData = await response.json();
    } catch (e) {
      errorData = { message: "Unknown error" };
    }
    switch (response.status) {
      case 401:
        throw new Error("API key is invalid or expired");
      case 404:
        throw new Error("Shared note not found. It may have been deleted.");
      case 429:
        throw new Error("Too many requests. Please wait before trying again.");
      case 500:
        throw new Error("Server error. Please try again later.");
      default:
        throw new Error(errorData.message || `HTTP ${response.status} error`);
    }
  }
};

// src/share-manager.ts
var ShareManager = class {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }
  async addShareMetadata(content, shareUrl, sharedAt) {
    const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n/;
    const match = content.match(frontmatterRegex);
    if (match) {
      const existingFrontmatter = match[1];
      const contentWithoutFrontmatter = content.substring(match[0].length);
      const newFrontmatter = `${existingFrontmatter}
shareUrl: ${shareUrl}
sharedAt: ${sharedAt}`;
      return `---
${newFrontmatter}
---
${contentWithoutFrontmatter}`;
    } else {
      const newFrontmatter = `shareUrl: ${shareUrl}
sharedAt: ${sharedAt}`;
      return `---
${newFrontmatter}
---
${content}`;
    }
  }
  async removeShareMetadata(content) {
    const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n/;
    const match = content.match(frontmatterRegex);
    if (!match) {
      return content;
    }
    const frontmatter = match[1];
    const contentWithoutFrontmatter = content.substring(match[0].length);
    const lines = frontmatter.split("\n").filter(
      (line) => !line.trim().startsWith("shareUrl:") && !line.trim().startsWith("shareId:") && !line.trim().startsWith("sharedAt:")
    );
    if (lines.length === 0 || lines.every((line) => line.trim() === "")) {
      return contentWithoutFrontmatter;
    } else {
      return `---
${lines.join("\n")}
---
${contentWithoutFrontmatter}`;
    }
  }
  isNoteShared(content) {
    try {
      const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n/;
      const match = content.match(frontmatterRegex);
      if (!match) {
        return false;
      }
      const frontmatter = match[1];
      if (frontmatter.includes("[unclosed") || frontmatter.includes("invalid yaml:")) {
        return false;
      }
      return (frontmatter.includes("shareUrl:") || frontmatter.includes("shareId:")) && frontmatter.split("\n").some((line) => {
        const shareUrlMatch = line.trim().match(/^shareUrl:\s*(.+)$/);
        const shareIdMatch = line.trim().match(/^shareId:\s*(.+)$/);
        return shareUrlMatch && shareUrlMatch[1].trim() !== "" || shareIdMatch && shareIdMatch[1].trim() !== "";
      });
    } catch (error) {
      return false;
    }
  }
  getShareUrl(content) {
    try {
      const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n/;
      const match = content.match(frontmatterRegex);
      if (!match) {
        return null;
      }
      const frontmatter = match[1];
      if (frontmatter.includes("[unclosed") || frontmatter.includes("invalid yaml:")) {
        return null;
      }
      const lines = frontmatter.split("\n");
      for (const line of lines) {
        const shareUrlMatch = line.trim().match(/^shareUrl:\s*(.+)$/);
        if (shareUrlMatch) {
          const shareUrl = shareUrlMatch[1].trim();
          return shareUrl === "" ? null : shareUrl;
        }
      }
      return null;
    } catch (error) {
      return null;
    }
  }
  getShareId(content) {
    try {
      const shareUrl = this.getShareUrl(content);
      if (shareUrl) {
        const match = shareUrl.match(/\/share\/([^\/]+)$/);
        return match ? match[1] : null;
      }
      const frontmatterRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n/;
      const fmMatch = content.match(frontmatterRegex);
      if (!fmMatch) {
        return null;
      }
      const frontmatter = fmMatch[1];
      const lines = frontmatter.split("\n");
      for (const line of lines) {
        const shareIdMatch = line.trim().match(/^shareId:\s*(.+)$/);
        if (shareIdMatch) {
          const shareId = shareIdMatch[1].trim();
          return shareId === "" ? null : shareId;
        }
      }
      return null;
    } catch (error) {
      return null;
    }
  }
  async shareNote(content) {
    const existingShareId = this.getShareId(content);
    if (existingShareId) {
      const updateResult = await this.apiClient.updateNote(existingShareId, content);
      return {
        shareUrl: `https://share.obsidiancomments.com/${existingShareId}`,
        shareId: existingShareId,
        updatedContent: content,
        wasUpdate: true
      };
    } else {
      const shareResponse = await this.apiClient.shareNote(content);
      const updatedContent = await this.addShareMetadata(
        content,
        shareResponse.shareUrl,
        shareResponse.createdAt || (/* @__PURE__ */ new Date()).toISOString()
      );
      return {
        shareUrl: shareResponse.shareUrl,
        shareId: shareResponse.shareId,
        updatedContent,
        wasUpdate: false
      };
    }
  }
  async unshareNote(content) {
    const shareId = this.getShareId(content);
    if (!shareId) {
      return content;
    }
    await this.apiClient.deleteShare(shareId);
    return await this.removeShareMetadata(content);
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  apiKey: "",
  serverUrl: "https://obsidiancomments.lakestrom.com",
  copyToClipboard: true,
  showNotifications: true,
  defaultPermissions: "edit"
};
function validateSettings(settings) {
  const errors = [];
  if (settings.apiKey && settings.apiKey.trim() !== "" && settings.apiKey.length < 20) {
    errors.push("API key must be at least 20 characters long");
  }
  if (settings.serverUrl) {
    try {
      const url = new URL(settings.serverUrl);
      const isLocalhost = url.hostname.includes("localhost") || url.hostname.includes("127.0.0.1");
      const isHttps = url.protocol === "https:";
      if (!isHttps && !isLocalhost) {
        errors.push("Server URL must use HTTPS for security");
      }
    } catch (e) {
      errors.push("Invalid server URL format");
    }
  }
  if (settings.defaultPermissions && settings.defaultPermissions !== "view" && settings.defaultPermissions !== "edit") {
    errors.push('Default permissions must be either "view" or "edit"');
  }
  return {
    isValid: errors.length === 0,
    errors
  };
}
var SettingsManager = class {
  constructor(app) {
    this.app = app;
    this.settings = { ...DEFAULT_SETTINGS };
  }
  async loadSettings() {
    const settingsPath = this.getSettingsPath();
    try {
      if (await this.app.vault.adapter.exists(settingsPath)) {
        const data = await this.app.vault.adapter.read(settingsPath);
        const savedSettings = JSON.parse(data);
        this.settings = { ...DEFAULT_SETTINGS, ...savedSettings };
      }
    } catch (error) {
      this.settings = { ...DEFAULT_SETTINGS };
    }
  }
  async saveSettings() {
    try {
      const settingsPath = this.getSettingsPath();
      await this.app.vault.adapter.write(
        settingsPath,
        JSON.stringify(this.settings, null, 2)
      );
    } catch (error) {
      throw new Error(`Failed to save settings: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async updateSettings(updates) {
    const newSettings = { ...this.settings, ...updates };
    const validation = validateSettings(newSettings);
    if (!validation.isValid) {
      throw new Error("Invalid settings update");
    }
    this.settings = newSettings;
    await this.saveSettings();
  }
  async resetSettings() {
    this.settings = { ...DEFAULT_SETTINGS };
    await this.saveSettings();
  }
  getSettingsPath() {
    return ".obsidian/plugins/obsidian-comments/data.json";
  }
  async isFirstRun() {
    return !await this.app.vault.adapter.exists(this.getSettingsPath());
  }
  exportSettings(options) {
    const settingsToExport = (options == null ? void 0 : options.excludeSensitive) ? { ...this.settings, apiKey: void 0 } : this.settings;
    return JSON.stringify(settingsToExport, null, 2);
  }
  async importSettings(settingsJson) {
    try {
      const importedSettings = JSON.parse(settingsJson);
      const validation = validateSettings(importedSettings);
      if (!validation.isValid) {
        throw new Error("Imported settings are invalid");
      }
      this.settings = { ...DEFAULT_SETTINGS, ...importedSettings };
      await this.saveSettings();
    } catch (error) {
      if (error instanceof Error && error.message.includes("Imported settings are invalid")) {
        throw error;
      }
      throw new Error("Invalid settings format");
    }
  }
};

// src/main.ts
var ObsidianCommentsPlugin = class extends import_obsidian.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.statusBarItem = null;
    this.settingsManager = new SettingsManager(app);
    this.apiClient = new ApiClient({
      apiKey: "temporary-initialization-key-12345",
      serverUrl: DEFAULT_SETTINGS.serverUrl
    });
    this.shareManager = new ShareManager(this.apiClient);
  }
  async onload() {
    await this.settingsManager.loadSettings();
    if (this.settingsManager.settings && this.settingsManager.settings.apiKey && this.settingsManager.settings.apiKey !== "") {
      this.apiClient = new ApiClient({
        apiKey: this.settingsManager.settings.apiKey,
        serverUrl: this.settingsManager.settings.serverUrl
      });
      this.shareManager = new ShareManager(this.apiClient);
    }
    this.addCommand({
      id: "share-note",
      name: "Share current note online",
      callback: () => this.shareCurrentNote()
    });
    this.addCommand({
      id: "unshare-note",
      name: "Stop sharing current note",
      callback: () => this.unshareCurrentNote()
    });
    this.addRibbonIcon("share", "Share current note", () => {
      this.shareCurrentNote();
    });
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.setText("");
    this.addSettingTab(new ObsidianCommentsSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.updateSharingStatus();
      })
    );
    await this.updateSharingStatus();
  }
  async shareCurrentNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian.Notice("No active file to share");
      return;
    }
    try {
      const content = await this.app.vault.read(activeFile);
      const result = await this.shareManager.shareNote(content);
      await this.app.vault.modify(activeFile, result.updatedContent);
      if (this.settingsManager.settings.copyToClipboard) {
        await navigator.clipboard.writeText(result.shareUrl);
      }
      if (this.settingsManager.settings.showNotifications) {
        const message = result.wasUpdate ? "Note updated and shared!" : "Note shared! URL copied to clipboard.";
        new import_obsidian.Notice(message);
      }
      await this.updateSharingStatus();
    } catch (error) {
      new import_obsidian.Notice(`Failed to share note: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async unshareCurrentNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian.Notice("No active file to unshare");
      return;
    }
    try {
      const content = await this.app.vault.read(activeFile);
      const updatedContent = await this.shareManager.unshareNote(content);
      await this.app.vault.modify(activeFile, updatedContent);
      if (this.settingsManager.settings.showNotifications) {
        new import_obsidian.Notice("Note unshared successfully.");
      }
      await this.updateSharingStatus();
    } catch (error) {
      new import_obsidian.Notice(`Failed to unshare note: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async shareFileNote(file) {
    try {
      const content = await this.app.vault.read(file);
      const result = await this.shareManager.shareNote(content);
      await this.app.vault.modify(file, result.updatedContent);
      if (this.settingsManager.settings.copyToClipboard) {
        await navigator.clipboard.writeText(result.shareUrl);
      }
      if (this.settingsManager.settings.showNotifications) {
        new import_obsidian.Notice("Note shared! URL copied to clipboard.");
      }
    } catch (error) {
      new import_obsidian.Notice(`Failed to share note: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async unshareFileNote(file) {
    try {
      const content = await this.app.vault.read(file);
      const updatedContent = await this.shareManager.unshareNote(content);
      await this.app.vault.modify(file, updatedContent);
      if (this.settingsManager.settings.showNotifications) {
        new import_obsidian.Notice("Note unshared successfully.");
      }
    } catch (error) {
      new import_obsidian.Notice(`Failed to unshare note: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async updateSharingStatus() {
    if (!this.statusBarItem)
      return;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      this.statusBarItem.setText("");
      return;
    }
    try {
      const content = await this.app.vault.read(activeFile);
      const isShared = this.shareManager.isNoteShared(content);
      this.statusBarItem.setText(isShared ? "\u{1F4E4} Shared" : "");
    } catch (error) {
      this.statusBarItem.setText("");
    }
  }
  async onSettingsChange(newSettings) {
    this.settingsManager.settings = newSettings;
    if (newSettings.apiKey) {
      this.apiClient = new ApiClient({
        apiKey: newSettings.apiKey,
        serverUrl: newSettings.serverUrl
      });
      this.shareManager = new ShareManager(this.apiClient);
    }
  }
  onunload() {
  }
};
var ObsidianCommentsSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Obsidian Comments Settings" });
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("Your API key for the sharing service").addText(
      (text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settingsManager.settings.apiKey).onChange(async (value) => {
        this.plugin.settingsManager.settings.apiKey = value;
        await this.plugin.settingsManager.saveSettings();
        await this.plugin.onSettingsChange(this.plugin.settingsManager.settings);
      })
    );
    new import_obsidian.Setting(containerEl).setName("Server URL").setDesc("URL of the sharing service").addText(
      (text) => text.setPlaceholder("https://api.obsidiancomments.com").setValue(this.plugin.settingsManager.settings.serverUrl).onChange(async (value) => {
        this.plugin.settingsManager.settings.serverUrl = value;
        await this.plugin.settingsManager.saveSettings();
        await this.plugin.onSettingsChange(this.plugin.settingsManager.settings);
      })
    );
    new import_obsidian.Setting(containerEl).setName("Copy to clipboard").setDesc("Automatically copy share URL to clipboard").addToggle(
      (toggle) => toggle.setValue(this.plugin.settingsManager.settings.copyToClipboard).onChange(async (value) => {
        this.plugin.settingsManager.settings.copyToClipboard = value;
        await this.plugin.settingsManager.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show notifications").setDesc("Show success/error notifications").addToggle(
      (toggle) => toggle.setValue(this.plugin.settingsManager.settings.showNotifications).onChange(async (value) => {
        this.plugin.settingsManager.settings.showNotifications = value;
        await this.plugin.settingsManager.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default permissions").setDesc("Default permission level for shared notes").addDropdown(
      (dropdown) => dropdown.addOption("view", "View only").addOption("edit", "Edit").setValue(this.plugin.settingsManager.settings.defaultPermissions).onChange(async (value) => {
        this.plugin.settingsManager.settings.defaultPermissions = value;
        await this.plugin.settingsManager.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Test connection").setDesc("Test your API key and connection").addButton(
      (button) => button.setButtonText("Test").setCta().onClick(async () => {
        try {
          button.setButtonText("Testing...");
          await this.plugin.apiClient.testConnection();
          new import_obsidian.Notice("Connection successful!");
          button.setButtonText("Test");
        } catch (error) {
          new import_obsidian.Notice(`Connection failed: ${error instanceof Error ? error.message : "Unknown error"}`);
          button.setButtonText("Test");
        }
      })
    );
  }
};
var main_default = ObsidianCommentsPlugin;
